# 分布式缓存
## Day1
### 前言
在这一天主要实现了一个`LRU`策略的`cache`。其实最主要的部分就是去维护了一个`hashmap + 双向链表`。使用`hashmap`是为了实现`O(1)`查询，双向链表可以很方便的将元素移动到队首或者队尾。
### go的list
这里使用的是`go`的`container`中的双向链表`list`中的元素，不过其真实结点是`Element`来代表的，`list.List`是对链表的又一层封装，在`list.List`里面提供了一个可以`O(1)`查询链表长度的方法`Len`
### Value值的封装
因为缓存中存储的可以是各种各样的数据，所以对于缓存中的`value`来说，我们需要把这个`value`的类型声明为`interface`来确保存储的数据类型是万能的，同时，为了方便查询缓存中存储的值的大小，可以给`Value`类型声明一个函数`Len`，要求在传递数据的时候所有的`value`必须实现这个`Len`方法，这样就可以很方便的计算长度。
### Entry
真正存储在缓存数据里面的类型是`entry`类型的数据，也就是说这个双向链表里面存储的其实就是`entry`类型的数据，在`entry`数据里面，除了真正的`value`外，还额外封装了一个`key`字段，这个`key`与`add`和`map`里面存储的`key`相同。额外存储这个`key`的原因是在删除的时候，由于删除是惰性的(不会将接口暴露给用户)，如果不添加`key`，删除的时候是无法得知这个`key`的，所以也就无法从`map`里面删除这个记录。
### 增删查改
在这些方法里面需要注意很多细节，例如新增的时候要考虑新增`map`、`node`、空间占用资源重新计算等，还是需要小心实现的。

## Day2
### 设计理念
如果一个数据结构不需要修改自身，并且占用内存不大，或者不想修改自身，那么在传递类型参数的时候需要选择`值传递`；相反，则需要传递`引用类型`。
### 并发数据结构
显然，在读写数据的时候要考虑并发问题，对于一个`cache`来说，并发写可能会导致数据丢失。对此，我们可以给数据添加一个互斥锁。
> 为什么不是读写锁
>
> 读写锁可以支持并发读和同一时刻只有一个`goroutine`在写入数据。在用`Get`的方式去读取数据的时候，似乎可以使用读锁？
> 实际上是不可以的，这是因为在`Get`读的时候，`lru`也会移动链表数据。所以只使用读锁是并未考虑到`Get`请求可能会更新数据的可能。