# 分布式缓存
## Day1
### 前言
在这一天主要实现了一个`LRU`策略的`cache`。其实最主要的部分就是去维护了一个`hashmap + 双向链表`。使用`hashmap`是为了实现`O(1)`查询，双向链表可以很方便的将元素移动到队首或者队尾。
### go的list
这里使用的是`go`的`container`中的双向链表`list`中的元素，不过其真实结点是`Element`来代表的，`list.List`是对链表的又一层封装，在`list.List`里面提供了一个可以`O(1)`查询链表长度的方法`Len`
### Value值的封装
因为缓存中存储的可以是各种各样的数据，所以对于缓存中的`value`来说，我们需要把这个`value`的类型声明为`interface`来确保存储的数据类型是万能的，同时，为了方便查询缓存中存储的值的大小，可以给`Value`类型声明一个函数`Len`，要求在传递数据的时候所有的`value`必须实现这个`Len`方法，这样就可以很方便的计算长度。
### Entry
真正存储在缓存数据里面的类型是`entry`类型的数据，也就是说这个双向链表里面存储的其实就是`entry`类型的数据，在`entry`数据里面，除了真正的`value`外，还额外封装了一个`key`字段，这个`key`与`add`和`map`里面存储的`key`相同。额外存储这个`key`的原因是在删除的时候，由于删除是惰性的(不会将接口暴露给用户)，如果不添加`key`，删除的时候是无法得知这个`key`的，所以也就无法从`map`里面删除这个记录。
### 增删查改
在这些方法里面需要注意很多细节，例如新增的时候要考虑新增`map`、`node`、空间占用资源重新计算等，还是需要小心实现的。